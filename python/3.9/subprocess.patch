diff --git a/Lib/subprocess.py b/Lib/subprocess.py
index 4effc1d8b3..3c7ac5b812 100644
--- a/Lib/subprocess.py
+++ b/Lib/subprocess.py
@@ -847,7 +847,15 @@ class Popen(object):
         # yet remain good for interactive users trying to exit a tool.
         self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()
 
-        self._closed_child_pipe_fds = False
+        self._child_pipes_to_close = set()
+        if stdin == PIPE:
+            self._child_pipes_to_close.add(p2cread)
+        if stdout == PIPE:
+            self._child_pipes_to_close.add(c2pwrite)
+        if stderr == PIPE:
+            self._child_pipes_to_close.add(errwrite)
+        if hasattr(self, '_devnull'):
+            self._child_pipes_to_close.add(self._devnull)
 
         if self.text_mode:
             if bufsize == 1:
@@ -959,31 +967,7 @@ class Popen(object):
                                 start_new_session)
         except:
             # Cleanup if the child failed starting.
-            for f in filter(None, (self.stdin, self.stdout, self.stderr)):
-                try:
-                    f.close()
-                except OSError:
-                    pass  # Ignore EBADF or other errors.
-
-            if not self._closed_child_pipe_fds:
-                to_close = []
-                if stdin == PIPE:
-                    to_close.append(p2cread)
-                if stdout == PIPE:
-                    to_close.append(c2pwrite)
-                if stderr == PIPE:
-                    to_close.append(errwrite)
-                if hasattr(self, '_devnull'):
-                    to_close.append(self._devnull)
-                for fd in to_close:
-                    try:
-                        if _mswindows and isinstance(fd, Handle):
-                            fd.Close()
-                        else:
-                            os.close(fd)
-                    except OSError:
-                        pass
-
+            self._cleanup_on_exec_failure()
             raise
 
     def __repr__(self):
@@ -1007,6 +991,57 @@ class Popen(object):
     def universal_newlines(self, universal_newlines):
         self.text_mode = bool(universal_newlines)
 
+    def _cleanup_on_exec_failure(self):
+        for f in filter(None, (self.stdin, self.stdout, self.stderr)):
+            try:
+                f.close()
+            except OSError:
+                pass  # Ignore EBADF or other errors.
+
+        for fd in self._child_pipes_to_close:
+            try:
+                if _mswindows and isinstance(fd, Handle):
+                    fd.Close()
+                else:
+                    os.close(fd)
+            except OSError:
+                pass
+
+        self._child_pipes_to_close.clear()
+
+    def _check_exec_result(self, orig_executable, cwd, errpipe_data):
+        try:
+            os.waitpid(self.pid, 0)
+        except ChildProcessError:
+            pass
+        try:
+            exception_name, hex_errno, err_msg = (
+                    errpipe_data.split(b':', 2))
+        except ValueError:
+            exception_name = b'SubprocessError'
+            hex_errno = b'0'
+            err_msg = (b'Bad exception data from child: ' +
+                        repr(errpipe_data))
+        child_exception_type = getattr(
+                builtins, exception_name.decode('ascii'),
+                SubprocessError)
+        err_msg = err_msg.decode(errors="surrogatepass")
+        if issubclass(child_exception_type, OSError) and hex_errno:
+            errno_num = int(hex_errno, 16)
+            child_exec_never_called = (err_msg == "noexec")
+            if child_exec_never_called:
+                err_msg = ""
+            if errno_num != 0:
+                err_msg = os.strerror(errno_num)
+                if errno_num == errno.ENOENT:
+                    if child_exec_never_called:
+                        # The error must be from chdir(cwd).
+                        err_msg += ': ' + repr(cwd)
+                    else:
+                        err_msg += ': ' + repr(orig_executable)
+            raise child_exception_type(errno_num, err_msg)
+        raise child_exception_type(err_msg)
+
     def _translate_newlines(self, data, encoding, errors):
         data = data.decode(encoding, errors)
         return data.replace("\r\n", "\n").replace("\r", "\n")
@@ -1211,27 +1246,37 @@ class Popen(object):
         # self._devnull is not always defined.
         devnull_fd = getattr(self, '_devnull', None)
 
-        with contextlib.ExitStack() as stack:
-            if _mswindows:
-                if p2cread != -1:
-                    stack.callback(p2cread.Close)
-                if c2pwrite != -1:
-                    stack.callback(c2pwrite.Close)
-                if errwrite != -1:
-                    stack.callback(errwrite.Close)
-            else:
-                if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
-                    stack.callback(os.close, p2cread)
-                if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
-                    stack.callback(os.close, c2pwrite)
-                if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
-                    stack.callback(os.close, errwrite)
+        to_close = set()
+        errpipe_read, _ = os.pipe()
+
+        try:
+            with contextlib.ExitStack() as stack:
+                if _mswindows:
+                    if p2cread != -1:
+                        stack.callback(p2cread.Close)
+                    if c2pwrite != -1:
+                        stack.callback(c2pwrite.Close)
+                    if errwrite != -1:
+                        stack.callback(errwrite.Close)
+                else:
+                    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
+                        to_close.add(p2cread)
+                    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
+                        to_close.add(c2pwrite)
+                    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
+                        to_close.add(errwrite)
+
+                if devnull_fd is not None:
+                    to_close.add(devnull_fd)
 
-            if devnull_fd is not None:
-                stack.callback(os.close, devnull_fd)
+            for fd in to_close:
+                os.close(fd)
+                # Prevent a double close of these fds from __init__ on error.
+                self._child_pipes_to_close.remove(fd)
 
-        # Prevent a double close of these handles/fds from __init__ on error.
-        self._closed_child_pipe_fds = True
+        except:
+            os.close(errpipe_read)
+            raise
 
     if _mswindows:
         #
@@ -1769,7 +1814,15 @@ class Popen(object):
                 self._close_pipe_fds(p2cread, p2cwrite,
                                      c2pread, c2pwrite,
                                      errread, errwrite)
+            except:
+                os.close(errpipe_read)
+                raise
+
+            self._wait_exec_done(orig_executable, cwd, errpipe_read)
 
+        def _wait_exec_done(self, orig_executable, cwd, errpipe_read):
+            assert errpipe_read is not None
+            try:
                 # Wait for exec to fail or succeed; possibly raising an
                 # exception (limited in size)
                 errpipe_data = bytearray()
@@ -1783,44 +1836,7 @@ class Popen(object):
                 os.close(errpipe_read)
 
             if errpipe_data:
-                try:
-                    pid, sts = os.waitpid(self.pid, 0)
-                    if pid == self.pid:
-                        self._handle_exitstatus(sts)
-                    else:
-                        self.returncode = sys.maxsize
-                except ChildProcessError:
-                    pass
-
-                try:
-                    exception_name, hex_errno, err_msg = (
-                            errpipe_data.split(b':', 2))
-                    # The encoding here should match the encoding
-                    # written in by the subprocess implementations
-                    # like _posixsubprocess
-                    err_msg = err_msg.decode()
-                except ValueError:
-                    exception_name = b'SubprocessError'
-                    hex_errno = b'0'
-                    err_msg = 'Bad exception data from child: {!r}'.format(
-                                  bytes(errpipe_data))
-                child_exception_type = getattr(
-                        builtins, exception_name.decode('ascii'),
-                        SubprocessError)
-                if issubclass(child_exception_type, OSError) and hex_errno:
-                    errno_num = int(hex_errno, 16)
-                    child_exec_never_called = (err_msg == "noexec")
-                    if child_exec_never_called:
-                        err_msg = ""
-                        # The error must be from chdir(cwd).
-                        err_filename = cwd
-                    else:
-                        err_filename = orig_executable
-                    if errno_num != 0:
-                        err_msg = os.strerror(errno_num)
-                    raise child_exception_type(errno_num, err_msg, err_filename)
-                raise child_exception_type(err_msg)
-
+                self._check_exec_result(orig_executable, cwd, errpipe_data)
 
         def _handle_exitstatus(self, sts,
                                waitstatus_to_exitcode=os.waitstatus_to_exitcode,
